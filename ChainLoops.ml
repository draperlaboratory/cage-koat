(**
   Build a set of test instances which chain a set of very simple loops together.
   If '-' is a bit of straight line code, and 'O' is a loop, we can think of the
   instances generated by this tool as being strings accepted by the following:
   [-*O+-*]+
*)

let rec listHelp = function
  | 0 -> [0]
  | x -> x :: listHelp (x - 1)

let list i =
  List.rev (listHelp i)

let getFname i = Printf.sprintf "f%i" i

let argHelper = function
  | 0 -> "a"
  | 1 -> "b"
  | 2 -> "c"
  | 3 -> "d"
  | 4 -> "e"
  | 5 -> "g"
  | 6 -> "h"
  | 7 -> "i"
  | 8 -> "j"
  | 9 -> "k"
  | 10 -> "l"
  | 11 -> "m"
  | 12 -> "n"
  | 13 -> "o"
  | 14 -> "p"
  | 15 -> "q"
  | 16 -> "r"
  | 17 -> "s"
  | 18 -> "t"
  | 19 -> "u"
  | 20 -> "v"
  | 21 -> "w"
  | 22 -> "y"
  | 23 -> "z"
  | x -> Printf.sprintf "x%i" (x - 24)

let arg i =
  Poly.fromVar (argHelper i)

let argDecrement target this i =
  let thisArg = arg i in
  if target = this
  then Poly.minus thisArg Poly.one
  else thisArg

let lefthandTerm arity i =
  let args = List.map arg (list (arity - 1)) in
  let fn = getFname i in
  { Term.fn = fn; Term.args = args; }

let straightSegment arity startIndex =
  let lhs = lefthandTerm arity startIndex in
  let rhs = lefthandTerm arity (startIndex + 1) in
  Comrule.createRule lhs [rhs] []

let closeLoop arity loopStart thisIndex =
  let argNums = list (arity - 1) in
  let lhs = lefthandTerm arity thisIndex
  and rhs = { Term.fn = getFname loopStart;
              args = List.mapi (argDecrement loopStart) argNums; }
  and cond = Pc.Geq (arg loopStart, Poly.zero) in
  Comrule.createRule lhs [rhs] [cond]

let exitLoop arity startIndex =
  let lhs = lefthandTerm arity startIndex
  and rhs = lefthandTerm arity (startIndex + 1)
  and cond = Pc.Equ (arg startIndex, Poly.zero) in
  Comrule.createRule lhs [rhs] [cond]

let rec buildStraight arity sindex = function
  | 0 -> []
  | i -> straightSegment arity sindex :: buildStraight arity sindex (i - 1)

let rec buildLoop arity loopStart loopEnd = function
  | i when i = loopStart ->
    exitLoop arity loopStart :: buildLoop arity loopStart loopEnd (i + 1)
  | i when i = loopEnd ->
        closeLoop arity loopStart loopEnd :: []
  | i ->
    straightSegment arity i :: buildLoop arity loopStart loopEnd (i + 1)

type range = {
  start : int;
  stop : int;
}

type segment =
| Linear of range
| Loop of range

type program = segment list

let rec computeArityHelper = function
  | [] -> 0
  | Linear _ :: tl -> computeArityHelper tl
  | Loop r :: tl -> 1 + computeArityHelper tl

let computeArity prgn =
  (* I want all programs to have at least arity 1, even if they're linear. *)
  max 1 (computeArityHelper prgn)

let validSegment = function
  | Linear r
  | Loop r ->
    r.start <= r.stop && r.start >= 0

let segmentToComrule arity = function
  | Loop r -> buildLoop arity r.start r.stop r.start
  | Linear r ->  buildStraight arity r.start r.stop

let programToITS p =
  let arity = computeArity p in
  let convSeg = segmentToComrule arity in
  List.fold_left (fun accum pSeg -> convSeg pSeg @ accum) [] p


(*** Test Code beyond here ***)

(* some simple instances *)
let straightInstance = [Linear { start = 0; stop = 10; }]

let loopingInstance1 = [ Linear { start = 0; stop = 1; };
                         Loop { start = 1; stop = 1; };
                         Linear { start = 2; stop = 10; }; ]
let loopingInstance2 = [Loop {start = 0; stop = 0; }]
let loopingInstance3 = [Loop {start = 0; stop = 0; };
                     Loop {start = 1; stop = 1; };
                     Loop {start = 2; stop = 5; };
                     Linear {start = 5; stop = 10; };]

let main () =
  let printCR cr = Printf.printf "%s\n" (Comrule.toString cr) in
  Printf.eprintf "Chain loops debugger\n";
  Printf.eprintf "Straight line instance:\n";
  List.iter printCR (programToITS straightInstance);
  Printf.eprintf "Loop instance 1:\n";
  List.iter printCR (programToITS loopingInstance1);
  Printf.eprintf "Loop instance 2:\n";
  List.iter printCR (programToITS loopingInstance2);
  Printf.eprintf "Loop instance 3:\n";
  List.iter printCR (programToITS loopingInstance3);
  Printf.eprintf "Goodbye!"


let _ = main ()
